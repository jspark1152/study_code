지금까지 봐온 알고리즘 정리

[그리디]
현재 상황에서 지금 당장 좋은 것만 고르는 방법
> 보통 그리디 유형은 사전에 특정 알고리즘 없이도 풀이가 가능


[구현]
구현은 생각해낸 알고리즘을 소스코드로 변환하는 과정
> 구현 유형은 풀이는 떠올리기 쉽지만 소스코드로 변환하는 것이 어려움


[DFS/BFS]
1. DFS = Depth-First Search
- 깊이 우선 탐색으로 graph에서 깊은 부분을 우선적으로 탐색
- 단순히 가장 깊숙이 위치하는 노드에 닿을 때 까지 탐색
1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드(작은 넘버링부터)를 스택에 넣고 방문 처리
2-1) 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복

2. BFS = Breadth-First Search
- 너비 우선 탐색으로 가까운 노드부터 탐색
1) 탐색 시작 노드를 큐에 삽입하고 방문 처리
2) 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복


[정렬]
정렬은 데이터를 특정한 기준에 따라서 순서대로 나열
1. 선택 정렬
- 매번 가장 작은 것을 선택하여 맨 앞의 데이터와 위치 변경

2. 삽입 정렬
- 특정 데이터를 적절한 위치에 삽입
- 첫 번째 데이터를 기준으로 두 번째 데이터 위치 조정 후 그 다음 데이터 위치 조정을 반복

3. 퀵 정렬 (가장 많이 쓰이는 정렬 알고리즘)
- 리스트에서 첫 번째 데이터를 피벗으로 지정
- 피벗을 기준으로 리스트의 왼쪽에서 부터 피벗보다 큰 데이터 선택
- 피벗을 기준으로 리스트의 오른쪽에서 부터 피벗보다 작은 데이터 선택
- 이후 이 두 데이터의 위치를 교환
- 이를 반복하다가 선택한 작은 데이터가 큰 데이터보다 왼쪽에 올 경우 작은 데이터와 피벗의 위치를 교환
- 이는 피벗을 기준으로 좌측에는 피벗보다 작은 데이터, 우측에는 피벗보다 큰 데이터로 정렬(이를 분할이라함)
- 이제 좌측과 우측에 동일하게 퀵 정렬을 시행
** 기본 소스코드 보다는 조금 더 간결한 소스코드 표현을 기억해두도록 하자


[이진 탐색]
1. 순차 탐색
- 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인
- 리스트 내 데이터가 아무리 많아도 시간만 충분하다면 원하는 데이터를 찾을 수 있음

2. 이진 탐색 : 반으로 쪼개면서 탐색
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교
- 시작점, 끝점, 중간점 3가지 변수를 이용
1) 우선 배열 내부의 데이터 정렬
2) 첫 성분 = 시작점, 끝 성분 = 끝점 으로 세팅한 후 중간 지점을 중간점으로 지정
3) 찾고자하는 데이터보다
3-1) 중간점이 더 큰 경우 끝점을 중간지점으로 당겨옴
3-2) 중간점이 더 작은 경우 시작점을 중간지점으로 당겨옴
4) 중간점과 찾고자 하는 데이터가 같을 때까지 반복 후 Return

3. 트리 자료구조
- 노드와 노드의 연결로 표현, 각 노드는 정보를 가지는 정보의 단위
- 트리는 부모/자식 노드의 관계로 표현
- 계층적이고 정렬된 데이터를 다루기에 적합

4. 이진 탐색 트리 : 이진 탐색이 동작할 수 있도록 고안된 구조
- 다음 특징을 가지는 트리를 이진 탐색 트리라고 함
1) 부모 노드보다 왼쪽 자식 노드가 작음
2) 부모 노드보다 오른쪽 자식 노드가 큼
- 탐색 과정은 다음과 같음
1) 루트 부모 노드부터 찾고자 하는 데이터를 비교하여
1-1) 부모 노드보다 클 경우 좌측 자식 노드는 버리고 우측 자식 노드로 이동
1-2) 부모 노드보다 작을 경우 우측 자식 노드는 버리고 좌측 자식 노드로 이동
2) 데이터를 찾을 때 까지 반복


[다이나믹 프로그래밍]
- 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요
- 따라서 효육적인 알고리즘 작성이 요구
- 메모리 공간을 조금 더 사용하여 연산 속도를 증가시키는 기법 중 하나가 다이나믹 프로그래밍
- 탑다운과 보텀업 2가지 방식
- 대표적인 예시로 피보나치 수열 구현(단순 재귀방식으로의 구현이 아닌)
- 다이나믹 프로그래밍은 다음 조건을 만족할 때 사용
1) 큰문제를 작은 문제로 나눌 수 있음
2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일
- 메모이제이션 기법(캐싱) : 한 번 구한 결과를 메모리 공간에 저장(반복 계산을 하지 않도록)


[최단 경로]
- 가장 짧은 경로를 찾는 알고리즘
1. Dijkstra 알고리즘
- 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구하는 알고리즘
- 매번 비용이 적은 노드를 선택하는 과정을 반복
1) 출발 노드를 설정
2) 최단 거리 테이블을 초기화
3) 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택
4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5) 3), 4)을 반복
- 최단 거리 정보는 1차원 리스트에 저장하면서 계속 갱신


[그래프 이론]