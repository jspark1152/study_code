지금까지 봐온 알고리즘 정리

[그리디]
현재 상황에서 지금 당장 좋은 것만 고르는 방법
> 보통 그리디 유형은 사전에 특정 알고리즘 없이도 풀이가 가능


[구현]
구현은 생각해낸 알고리즘을 소스코드로 변환하는 과정
> 구현 유형은 풀이는 떠올리기 쉽지만 소스코드로 변환하는 것이 어려움


[DFS/BFS]
1. DFS = Depth-First Search
- 깊이 우선 탐색으로 graph에서 깊은 부분을 우선적으로 탐색
- 단순히 가장 깊숙이 위치하는 노드에 닿을 때 까지 탐색
1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드(작은 넘버링부터)를 스택에 넣고 방문 처리
2-1) 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복

2. BFS = Breadth-First Search
- 너비 우선 탐색으로 가까운 노드부터 탐색
1) 탐색 시작 노드를 큐에 삽입하고 방문 처리
2) 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복


[정렬]
정렬은 데이터를 특정한 기준에 따라서 순서대로 나열
1. 선택 정렬
- 매번 가장 작은 것을 선택하여 맨 앞의 데이터와 위치 변경

2. 삽입 정렬
- 특정 데이터를 적절한 위치에 삽입
- 첫 번째 데이터를 기준으로 두 번째 데이터 위치 조정 후 그 다음 데이터 위치 조정을 반복

3. 퀵 정렬 (가장 많이 쓰이는 정렬 알고리즘)
- 리스트에서 첫 번째 데이터를 피벗으로 지정
- 피벗을 기준으로 리스트의 왼쪽에서 부터 피벗보다 큰 데이터 선택
- 피벗을 기준으로 리스트의 오른쪽에서 부터 피벗보다 작은 데이터 선택
- 이후 이 두 데이터의 위치를 교환
- 이를 반복하다가 선택한 작은 데이터가 큰 데이터보다 왼쪽에 올 경우 작은 데이터와 피벗의 위치를 교환
- 이는 피벗을 기준으로 좌측에는 피벗보다 작은 데이터, 우측에는 피벗보다 큰 데이터로 정렬(이를 분할이라함)
- 이제 좌측과 우측에 동일하게 퀵 정렬을 시행
** 기본 소스코드 보다는 조금 더 간결한 소스코드 표현을 기억해두도록 하자


[이진 탐색]
1. 순차 탐색
- 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인
- 리스트 내 데이터가 아무리 많아도 시간만 충분하다면 원하는 데이터를 찾을 수 있음

2. 이진 탐색 : 반으로 쪼개면서 탐색
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교
- 시작점, 끝점, 중간점 3가지 변수를 이용
1) 우선 배열 내부의 데이터 정렬
2) 첫 성분 = 시작점, 끝 성분 = 끝점 으로 세팅한 후 중간 지점을 중간점으로 지정
3) 찾고자하는 데이터보다
3-1) 중간점이 더 큰 경우 끝점을 중간지점으로 당겨옴
3-2) 중간점이 더 작은 경우 시작점을 중간지점으로 당겨옴
4) 중간점과 찾고자 하는 데이터가 같을 때까지 반복 후 Return

3. 트리 자료구조
- 노드와 노드의 연결로 표현, 각 노드는 정보를 가지는 정보의 단위
- 트리는 부모/자식 노드의 관계로 표현
- 계층적이고 정렬된 데이터를 다루기에 적합

4. 이진 탐색 트리 : 이진 탐색이 동작할 수 있도록 고안된 구조
- 다음 특징을 가지는 트리를 이진 탐색 트리라고 함
1) 부모 노드보다 왼쪽 자식 노드가 작음
2) 부모 노드보다 오른쪽 자식 노드가 큼
- 탐색 과정은 다음과 같음
1) 루트 부모 노드부터 찾고자 하는 데이터를 비교하여
1-1) 부모 노드보다 클 경우 좌측 자식 노드는 버리고 우측 자식 노드로 이동
1-2) 부모 노드보다 작을 경우 우측 자식 노드는 버리고 좌측 자식 노드로 이동
2) 데이터를 찾을 때 까지 반복


[다이나믹 프로그래밍]
- 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요
- 따라서 효육적인 알고리즘 작성이 요구
- 메모리 공간을 조금 더 사용하여 연산 속도를 증가시키는 기법 중 하나가 다이나믹 프로그래밍
- 탑다운과 보텀업 2가지 방식
- 대표적인 예시로 피보나치 수열 구현(단순 재귀방식으로의 구현이 아닌)
- 다이나믹 프로그래밍은 다음 조건을 만족할 때 사용
1) 큰문제를 작은 문제로 나눌 수 있음
2) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일
- 메모이제이션 기법(캐싱) : 한 번 구한 결과를 메모리 공간에 저장(반복 계산을 하지 않도록)


[최단 경로]
- 가장 짧은 경로를 찾는 알고리즘
1. Dijkstra 알고리즘
- 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구하는 알고리즘
- 매번 비용이 적은 노드를 선택하는 과정을 반복
1) 출발 노드를 설정
2) 최단 거리 테이블을 초기화
3) 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택
4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5) 3), 4)을 반복
- 최단 거리 정보는 1차원 리스트에 저장하면서 계속 갱신
- 우선 순위 큐를 이용하는 코드 기억(heapq)
> heap은 성분의 첫 원소를 기준으로 정렬 후 pop시 가장 작은 값이 먼저 나옴
> 따라서 다익스트라 구현시에 최소 비용인 간선을 pop하는 원리

2. Floyd-Warshall 알고리즘
- 다익스트라 알고리즘은 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우 사용
- 플로이드 워셜은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구함
1) 다익스트라와는 다르게 2차원 리스트에 정보를 입력
1-1) (a, b) : a 에서 b로 가는데 드는 비용을 의미
2) (i, i) 성분을 0으로 초기화
3) 간선 정보를 통해 먼저 비용 정보를 입력
4) 이후 a에서 b로 가는 비용 / a에서 c를 거쳐 b로 가는 비용을 비교하여 적은 값으로 초기화
- 구현하는 과정에서 3중 반복문을 이용하는게 핵심


[그래프 이론]
- 그래프 : 노드와 노드 간의 연결된 엣지의 정보를 가지고 있는 자료 구조
- 트리 자료 구조 또한 다양한 알고리즘에서 사용
- 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현(이게 어려움)
1. 서로소 집합(Disjoint Sets)
- 수학에서의 그 서로소 개념과 동일함
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 이를 구현하기 위하여 union / find 연산 구현이 필요
- union : 2개의 원소가 포함된 집합을 하나의 집합으로 합
- find : 특정 원소가 속한 집합이 어떤 집합인지 알려줌
1) union 연산을 확인하고 서로 연결된 두 노드 A, B를 확인
1-1) A와 B의 루트 노드 A', B'을 각각 찾음
1-2) A'을 B'의 부모 노드로 설정(B'이 A'을 가리키도록)
2) 모든 union 연산을 처리할 때까지 1번 반복
- 포인트는 집합을 나타내는 지표가 해당 원소의 '부모 노드'(즉, 부분집합의 대표원소라고 봐도 무방)
- 부분 집합에서 값이 가장 작은 원소가 부모 노드 역할을 함

2. 사이클 판별
- 서로소 집합으로 사이클 판별 가능
- 3개 이상의 원소가 같은 부모 노드를 가질 때 Cycle 발생
ex) (1, 2) / (1, 3) / (2, 3) 인 경우 최종 (2, 3)을 확인 시 부모 노드가 1로 동일함

3. 신장 트리
- 하나의 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미
- Kruskal 알고리즘(최소 신장 트리 알고리즘)
- 가능한 최소 비용으로 신장 트리를 찾을 때 사용
1) 간선 데이터를 비용에 따라 오름차순으로 정렬
2) 간선을 하나씩 확인하여 현재 간선이 사이클을 발생시키는지 확인
2-1) 사이클이 발생하지 않는 경우 최소 신장 트리에 포함
2-2) 사이클이 발생할 경우 최소 신장트리에 포함시키지 않음
3) 모든 간선에 대하여 2번 반복

4. 위상 정렬
- 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'
- 선수과목을 고려한 학습 순서 설정하는 경우가 이에 해당
- 그래프 상에서 선후 관계가 있다면 위상정렬을 수행
- 진입 차수 : 특정 노드로 들어오는 간선의 개수
1) 진입 차수가 0인 노드를 큐에 삽입
2) 큐가 빌 때까지 다음 과정 반복
2-1) 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
2-2) 새롭게 진입차수가 0이 된 노드를 큐에 삽입