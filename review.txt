지금까지 봐온 알고리즘 정리

[그리디]
현재 상황에서 지금 당장 좋은 것만 고르는 방법
> 보통 그리디 유형은 사전에 특정 알고리즘 없이도 풀이가 가능

[구현]
구현은 생각해낸 알고리즘을 소스코드로 변환하는 과정
> 구현 유형은 풀이는 떠올리기 쉽지만 소스코드로 변환하는 것이 어려움

[DFS/BFS]
1. DFS = Depth-First Search
- 깊이 우선 탐색으로 graph에서 깊은 부분을 우선적으로 탐색
- 단순히 가장 깊숙이 위치하는 노드에 닿을 때 까지 탐색
1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드(작은 넘버링부터)를 스택에 넣고 방문 처리
2-1) 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복

2. BFS = Breadth-First Search
- 너비 우선 탐색으로 가까운 노드부터 탐색
1) 탐색 시작 노드를 큐에 삽입하고 방문 처리
2) 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
3) 2번 과정을 더 이상 수행할 수 없을 때까지 반복

[정렬]
정렬은 데이터를 특정한 기준에 따라서 순서대로 나열
1. 선택 정렬
- 매번 가장 작은 것을 선택하여 맨 앞의 데이터와 위치 변경

2. 삽입 정렬
- 특정 데이터를 적절한 위치에 삽입
- 첫 번째 데이터를 기준으로 두 번째 데이터 위치 조정 후 그 다음 데이터 위치 조정을 반복

3. 퀵 정렬 (가장 많이 쓰이는 정렬 알고리즘)
- 리스트에서 첫 번째 데이터를 피벗으로 지정
- 피벗을 기준으로 리스트의 왼쪽에서 부터 피벗보다 큰 데이터 선택
- 피벗을 기준으로 리스트의 오른쪽에서 부터 피벗보다 작은 데이터 선택
- 이후 이 두 데이터의 위치를 교환
- 이를 반복하다가 선택한 작은 데이터가 큰 데이터보다 왼쪽에 올 경우 작은 데이터와 피벗의 위치를 교환
- 이는 피벗을 기준으로 좌측에는 피벗보다 작은 데이터, 우측에는 피벗보다 큰 데이터로 정렬(이를 분할이라함)
- 이제 좌측과 우측에 동일하게 퀵 정렬을 시행
** 기본 소스코드 보다는 조금 더 간결한 소스코드 표현을 기억해두도록 하자


[이진 탐색]


[다이나믹 프로그래밍]


[최단 경로]


[그래프 이론]