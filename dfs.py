#DFS = Depth First Search : 깊이 우선 탐색
#그래프에서 깊은 부분을 우선적으로 탐색

#그래프의 구조
#노드(Node)와 간선(Edge)으로 표현되며 이때 노드를 정점(Vertex)이라고도 말함
#탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것
#두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다'라고 표현

#프로그래밍에서 그래프는 크게 2가지 방식으로 표현
#1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현
#2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현

#인접 행렬 방식은 2차원 배열에 노드가 연결된 형태를 기록
#연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성

INF = 999999999

graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)

#위 예제를 보면 Symmetric 형태를 띔
#자기 자신은 같기 때문에 0으로 표현
#1 <--> 2 는 연결이 되어 있지 않음을 알 수 있음

#인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
#파이썬에서는 별도의 라이브러리가 필요없음

graph = [[] for _ in range(3)]

graph[0].append((1, 7))
graph[0].append((2, 5))

graph[1].append((0, 7))

graph[2].append((0, 5))

print(graph)

#위 예제를 보면 연결되어 있지 않은 성분은 굳이 표현하지 않음
#좀 더 시각적으로 n번 노드가 몇개의 노드와 연결되어 있는지 바로 확인 가능

#메모리 측면
#인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 낭비
#인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리 측면에서 효율이 좋음
#하지만 인접 리스트 방식은 연결 정보를 얻는 속도가 느림

#DFS는 스택 자료구조를 이용하며 구체적인 동작 과정은 다음과 같음
#1. 탐색 시작 노드를 스택에 삽입하고 방문 처리.
#2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.
#3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복.

def dfs(graph, v, visited):
    visited[v] = True #방문 처리 False > True
    print(v, end = '') #방문한 곳 바로 출력
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

#그래프 정의시 오름차순으로 정렬하여 정의
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

dfs(graph, 1, visited)

#생소해서 그런가 살짝 이해가 잘 안감
#내가 구현 가능한건가 이거..
